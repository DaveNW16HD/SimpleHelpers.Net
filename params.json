{"name":"Simplehelpers.net","tagline":"Collection of simple pieces of utility code","body":"SimpleHelpers.Net\r\n=================\r\n\r\nCollection of simple pieces of utility code\r\n\r\nDescription and Examples\r\n--------\r\n<h3>MemoryCache</h3>\r\n\r\nSimple lightweight object in-memory cache, with a background timer to remove expired objects.\r\n\r\nFast in-memory cache for data that are expensive to create and can be used in a thread-safe manner.\r\n\r\nAll stored items are kept in concurrent data structures (ConcurrentDictionary) to allow multi-thread usage of the MemoryCache static methods. Note that the stored objects must be **thread-safe**, since the same instance of an object can and will be returned by multiple calls of *Get* methods. If you wish to use non-thread safe object instances you must use the *Remove* method to atomically (safelly) get and remove the object instance from the cache.\r\n\r\nNote: this nuget package contains csharp source code and depends on System.Collections.Concurrent introduced in .Net 4.0.\r\n\r\n**Configuration**\r\n\r\nSimple configuration of the MemoryCache settings. \r\nIt should be done for each type, since since the JIT compiler will generate different code at run time, MemoryCache<string> is considered a different class, for example, from MemoryCache<StringBuilder> or MemoryCache<byte[]>.\r\n\r\n```csharp\r\n\r\n// setup (called once in application initialization)\r\n\r\n// set a duration of an item in the cache to 1 second\r\nMemoryCache<string>.Expiration = TimeSpan.FromSeconds (1);\r\n// set the internal maintenance timed task to run each 500 ms removing expired items\r\nMemoryCache<string>.MaintenanceStep = TimeSpan.FromMilliseconds (500);\r\n// Our event, if we want to treat the removed expired items\r\nMemoryCache<string>.OnExpiration += (string key, string item) => \r\n{ \r\n    // do something\r\n};\r\n\r\n```\r\n\r\n**Example**\r\n\r\n```csharp\r\n\r\n// store an item\r\nMemoryCache<string>.Set (\"k1\", \"test\");\r\n\r\n// get it\r\nstring value = MemoryCache<string>.Get (\"k1\");\r\n// check if we got it\r\nif (value != null)\r\n{\r\n\t// ok we got it!\r\n}\r\n\r\n```\r\n\r\nUsing a factory to create a new item if the in memory cache does not have it.\r\n\r\n```csharp\r\n\r\n// prepare our factory\r\nvar factory = (string key) =>\r\n{\r\n    return key + DateTime.Now.ToString ();\r\n};\r\n\r\n// try to get the associated value if the cache does not have it\r\n// then use the factory to create a new one, store and return it.\r\nstring value = MemoryCache<string>.GetOrAdd (\"key2\", factory);\r\n\r\n```\r\n\r\nUsing a more complex concurrent scenario where, if the item is not found, we only want to call the factory only once.\r\nSo all concurrent calls will wait until factory (that is guaranteed to be called only once) has created and stored the new item, and will return it.\r\n\r\n```csharp\r\n\r\n// prepare our factory\r\nvar factory = (string key) =>\r\n{\r\n    return key + DateTime.Now.ToString ();\r\n};\r\n\r\n// try to get the associated value if the cache does not have it\r\n// then use the factory to create a new one, store and return it.\r\n// It the factory takes more than 250 milliseconds to create then new instance,\r\n// it will exit returning the default value for the class\r\nstring value = MemoryCache<string>.GetOrSyncAdd (\"key2\", factory, TimeSpan.FromMilliseconds (250));\r\n\r\n// check if we got it\r\nif (value != null)\r\n{\r\n\t// ok we got it!\r\n}\r\n\r\n```\r\n\r\n<h3>NamedLock</h3>\r\n\r\nSynchronization helper: a static lock collection associated with a key.\r\n\r\nNamedLock manages the lifetime of critical sections that can be accessed by a key (name) throughout the application. It also have some helper methods to allow a maximum wait time (timeout) to acquire the lock and safely release it.\r\n\t\r\nNote: this nuget package contains c# source code and depends on System.Collections.Concurrent introduced in .Net 4.0.\r\n\r\n**Example**\r\n\r\nSimple usage where we try to acquire the lock for 100 ms. \r\nSo if somewhere else in our application this same lock was already acquired, we will wait until we acquire the lock or 100 ms has passed.\r\n\r\n```csharp\r\n\r\nstring key = \"our lock name\";\r\n\r\nusing (var padlock = new NamedLock (key))\r\n{\r\n    if (padlock.Enter (TimeSpan.FromMilliseconds (100)))\r\n    {\r\n        // do something as we now own the lock\r\n    }\r\n    else\r\n    {\r\n        // do some other thing since we could not aquire the lock\r\n    }\r\n}\r\n\r\n```\r\n\r\nAnother usage example with a static helper method.\r\n\r\n```csharp\r\n\r\nstring key = \"our lock name\";\r\n\r\nusing (var padlock = NamedLock.CreateAndEnter (key, TimeSpan.FromMilliseconds (100)))\r\n{\r\n    if (padlock.IsLocked)\r\n    {\r\n        // do something                    \r\n    }                \r\n}\r\n\r\n```\r\n\r\n<h3>ObjectPool</h3>\r\n\r\nA simple lightweight object pool for fast and simple object reuse.\r\n\r\nFast lightweight thread-safe object pool for objects that are expensive to create or could efficiently be reused.\r\n\r\nNote: this nuget package contains c# source code and depends on System.Collections.Concurrent introduced in .Net 4.0.\r\n\r\n**Example**\r\n\r\n```csharp\r\n\r\n// Get or create a new random generator\r\nRandom rnd = ObjectPool<Random>.Get (CreateRandomGenerator);\r\n// start generating random numbers\r\ntry\r\n{\t\r\n\t// ...\r\n\t\r\n\tvar num = rnd.Next (max);\r\n\t\r\n\t// ...\r\n}\r\nfinally\r\n{\r\n\t// Release the random generator by putting it back in the object pool\r\n\tObjectPool<Random>.Put (rnd);\r\n}\r\n\r\n// our factory\r\nprivate static Random CreateRandomGenerator ()\r\n{\r\n\treturn new Random ((int)DateTime.UtcNow.Ticks);\r\n}\r\n\r\n```\r\n\r\n<h3>TimedQueue</h3>\r\nSimple lightweight queue that stores data in a concurrent queue and periodically process the queued items.\r\n\r\nUseful for:\r\n* processing items in batches;\r\n* grouping data for later processing;\r\n* async processing (consumer/producer);\r\n* etc.\r\n\r\nNote: this nuget package contains c# source code and depends on System.Collections.Concurrent introduced in .Net 4.0.\r\n\r\n**Configuration**\r\n\r\nSimple configuration of the TimedQueue settings. \r\nIt should be done for each type, since since the JIT compiler will generate differente code at run time, TimedQueue<string> is considered a diferent class, for example, from TimedQueue<StringBuilder> or TimedQueue<byte[]>.\r\n\r\n```csharp\r\n\r\n// setup (called once in application initialization)\r\n\r\n// set the queue timed task to run each 500 ms executing the registered action\r\nSimpleHelpers.TimedQueue<Our_Object>.TimerStep = TimeSpan.FromMilliseconds (500);\r\n// Our event, if we want to treat the removed expired items\r\nMemoryCache<string>.OnExecution += (IEnumerable<Our_Object> items) => \r\n{ \r\n\tforeach (var evt in items)\r\n\t\t// do something\r\n};\r\n\r\n```\r\n\r\n**Example**\r\n\r\n```csharp\r\n\r\n// our method that does an network call to store out object \r\n// and keeps retrying in case of failure\r\npublic static void SaveEvent (Our_Object evt)\r\n{\r\n\t// try to save\r\n\ttry\r\n\t{\r\n\t\tSaveOverTheInternet (evt);\r\n\t}\r\n\tcatch (System.IO.IOException ex)\r\n\t{\r\n\t\t// log.Error (ex);\r\n\t\tSimpleHelpers.TimedQueue<Our_Object>.Put (evt);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n<h3>ConfigManager</h3>\r\n\r\nSimple configuration manager to get and set the values in the AppSettings section of the default configuration file.\r\n\r\nNote: this nuget package contains csharp source code and depends on Generics introduced in .Net 2.0.\r\n\r\n**Configuration**\r\n\r\n```csharp\r\n\r\n// setup (called once in application initialization)\r\n\r\n// set to add any new keys added during the application execution\r\nConfigManager.AddNonExistingKeys = true;\r\n\r\n```\r\n\r\n** Example **\r\n\r\n```csharp\r\n\r\nstring address = ConfigManager.Get (\"MongoDBaddress\", \"localhost\");\r\nint port = ConfigManager.Get (\"MongoDBport\", 21766);\r\n\r\n```\r\n\r\n<h3>SQLiteStorage</h3>\r\n\r\nSimple key value storage using sqlite.\r\n\r\nAll member methods are thread-safe, so a instance can be safely be accessed by multiple threads.\r\n\r\nAll stored items are serialized to json by json.net.\r\n\r\nNote: this nuget package contains csharp source code and depends on .Net 4.0.\r\n\r\n**Configuration**\r\n\r\n```csharp\r\n\r\n// setup:\r\nSQLiteStorage<My_Class> db = new SQLiteStorage<My_Class> (\"path_to_my_file.sqlite\", \r\n\t\t\t\t\t\t\t  SQLiteStorageOptions.UniqueKeys ());\r\n\r\n```\r\n\r\n** Example **\r\n\r\n```csharp\r\n\r\n// create a new instance\r\nSQLiteStorage<My_Class> db = new SQLiteStorage<My_Class> (\"path_to_my_file.sqlite\", \r\n\t\t\t\t\t\t\t  SQLiteStorageOptions.UniqueKeys ());\r\n\r\n// save an item with a key associated\r\ndb.Set (\"my_key_for_this_item\", new My_Class ());\r\n// get it back\r\nMy_Class my_obj = db.Get (\"my_key_for_this_item\").FirstOrDefault ();\r\n\r\n// to save any changes, just call set again\r\ndb.Set (\"my_key_for_this_item\", my_obj);\r\n\r\n// get all stored items\r\nforeach (var item in db.Get ())\r\n{\r\n\t// ...\r\n}\r\n```\r\n\r\n\r\n### Welcome to GitHub Pages.\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here using GitHub Flavored Markdown, select a template crafted by a designer, and publish. After your page is generated, you can check out the new branch:\r\n\r\n```\r\n$ cd your_repo_root/repo_name\r\n$ git fetch origin\r\n$ git checkout gh-pages\r\n```\r\n\r\nIf you're using the GitHub for Mac, simply sync your repository and you'll see the new branch.\r\n\r\n### Designer Templates\r\nWe've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.\r\n\r\n### Rather Drive Stick?\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out the documentation at http://help.github.com/pages or contact support@github.com and we’ll help you sort it out.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}